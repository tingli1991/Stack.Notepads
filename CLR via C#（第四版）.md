
## 第4章：类型基础  
* 所有类型都从System.Object派生  
* 类型转换  
* 命名空间  
* 运行时的相互关系  

### 所有类型都从System.Object派生  
CLR(公共语言运行时)要求所有的类型最终都从System.Object类型派生，正因如此System.Object提供了如下表的公共实例方法。  

|     公共方法       |           说明                                                                                                                                           |
|--------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| Equals             | 对比两个对象是否具有相同的值，如果有则返回“True”																											|
| GetHashCode        | 返回对象值的hash码                                                                                                                                       |
| ToString           | 默认返回对象的完整名称(this.GetType().FullName)，但我们经常会重写该方法来返回对象状态标识的String对象                                                    |
| GetType            | 返回从Type派生的一个类型示例，指出调用GetType的那个对象是什么类型，同时返回的Type类型还可以配合反射来获取对象有关的元数据信息（例如：方法，属性以及字段）|
| MemberwiseClone    | 这个非虚方法创建类型的新实例，并将新对象的实例字段与this对象实例完全一致，返回对新实例的引用                                                             |
| Finalize           | 在垃圾回收器判断对象应该作为垃圾回收之后，在对象的内存被实际回收之前调用的虚方法，这是C#垃圾回收的一个重要方法                                           |  


## 第26章：线程基础  
### 26.6 使用专用线程执行异步的计算限制操作  
### 专用线程  
    创建专用线程需要构造System.Threading.Thread类的实例，向构造器传递一个方法名
使用线程的注意事项：
* 尽量使用线程池来执行异步的计算限制操作。
* 创建专用线程的条件：  
  线程需要以普通的优先级运行  
  需要线程表现为一个前台线程，线程池始终是后台线程  
  计算限制的任务需要长时间运行  
  需要启动线程，并可能会调用Thread的Abort方法来提前终止它  
*   

  
